initialize() {
	initializeSLiMModelType("nonWF");
	
	// record pedigrees
	initializeSLiMOptions(keepPedigrees = T);
	
	// output tree sequences
	initializeTreeSeq();
	
	// set mutation rate to 0
	// mutations will be added during the processing of the tree sequences
	initializeMutationRate(0);
	
	initializeSex("A");
	
	// number of villages
	defineConstant("N_VILLAGES", bash_Num_villages);
	
	// carrying capacity
	defineConstant("K", bash_carrying_capacity);
	
	// number of replicates
	defineConstant("N_REP", bash_Num_replicat);
	
	// chromosome sizes
	defineConstant("CHR_SIZE", bash_chr_size);
	
	// random fission
	defineConstant("RF", bash_random_fission);
	
	// fission threshold
	defineConstant("FITH", bash_fission_threshold);
	
	// friendly fission : groups stay in the same village. If not, a group moves to another village
	defineConstant("FF", bash_friendly_fission);
	
	// violence
	defineConstant("V", bash_violence);
	
	// extinction rate
	defineConstant("e", bash_extinction_rate);
	
	// descent rule
	defineConstant("DESCENT", "bash_descent_rule");
	
	// migration rate
	defineConstant("M_RATIO", bash_migration_rate);
	
	// residence rule
	defineConstant("RES", "bash_residence_rule");
	
	// female migration rate
	if (RES == "patrilocal") {
		defineConstant("MF_RATIO", 1);
		//defineConstant("MF_RATIO", runif(1, 0.9, 1));
	}
	else {
		defineConstant("MF_RATIO", 0);
		//defineConstant("MF_RATIO", runif(1, 0, 0.1));
	}
	
	// variance of the normal law used to draw growth rates
	defineConstant("sigma", bash_sigma);
	
	// growth rate
	defineConstant('R', bash_growth_rate);
	
	// transmission of growth rate to the new group
	defineConstant('TM', "bash_transmission");
	
	// non random initial groups
	defineConstant('RL', bash_random_lin);
	
	// add variance to growth rates at the moment of fission (ie TM)
	defineConstant('VARGR', bash_var_gr);
	
	// Output folder
	defineConstant('nameDir', "bash_namedir");
	
	// set neutral mutations and convert to substitution
	// TO DO : change marker numbers
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeMutationType("m2", 1.0, "f", 0.0); // Y marker
	initializeMutationType("m3", 1.0, "f", 0.0); // mt marker
	
	initializeMutationType("m4", 1.0, "f", 0.0); // village 1 marker
	initializeMutationType("m5", 1.0, "f", 0.0); // village 2 marker
	initializeMutationType("m6", 1.0, "f", 0.0); // village 3 marker	
	initializeMutationType("m7", 1.0, "f", 0.0); // village 4 marker	
	initializeMutationType("m8", 1.0, "f", 0.0); // village 5 marker
	
	initializeGenomicElementType("g1", m1, 1.0);
	
	defineConstant("UpperA", CHR_SIZE[0]);  // upper boundary for autosomes	
	defineConstant("LowerXY", CHR_SIZE[0] + 1);  // lower boundary for X/Y chromosomes
	defineConstant("UpperXY", CHR_SIZE[0] + CHR_SIZE[1] + 2);  // upper boundary for X/Y chromosomes	
	defineConstant("LowerMt", CHR_SIZE[0] + CHR_SIZE[1] + 3);  // lower boundary for mtDNA
	defineConstant("UpperMt", CHR_SIZE[0] + CHR_SIZE[1] + CHR_SIZE[2] + 4);  // upper boundary for mtDNA
	
	initializeGenomicElement(g1, 0, UpperMt);
	
	// recombination rate is set to 0 for Y chromosome and mtDNA
	initializeRecombinationRate(c(1.1e-8, 0.5, 0, 0.5, 1e-8), c(UpperA, LowerXY, UpperXY, LowerMt, UpperMt), sex='M');
	initializeRecombinationRate(c(1.1e-8, 0.5, 1e-8, 0.5, 0), c(UpperA, LowerXY, UpperXY, LowerMt, UpperMt), sex='F');
	
	if (V == F) {
		defineConstant("output", paste0("~/Documents/SLiM_model/Tables/Simulations_metrics/unilineal/regular/r=", R, '/sigma=', sigma, '/FT=', FITH, '/',  nameDir, "/"));
	}
	else
		defineConstant("output", paste0("~/Documents/SLiM_model/Tables/Simulations_metrics/unilineal/regular/r=", R, '/sigma=', sigma, '/FT=', FITH, '/',  '/e=', e, '/', nameDir, "/"));
}

1 first() {
	start = clock();
	
	// load the burn-in simulation
	suppressWarnings(T);
	sim.readFromPopulationFile(paste0(c('~/Documents/SLiM_model/Burn_in/outgroup_villages_unilineal_descent_burn_in_', asString(N_REP), '.trees')));
	inds = p1.individuals;
	nInds = size(inds);
	
	// load ancestors array
	if (RF == F) {
		if (DESCENT == 'patrilineal') {
			ID_temp = readFile(paste0(c('~/Documents/SLiM_model/Burn_in/patrilineal_ID_', asString(N_REP), '.txt')));
		}
		else {
			ID_temp = readFile(paste0(c('~/Documents/SLiM_model/Burn_in/matrilineal_ID_', asString(N_REP), '.txt')));
		}
		ID_temp = array(ID_temp, c(size(ID_temp), 1));
		ID = NULL;
		for (i in seq(0, nrow(ID_temp)-1)) {
			ID = rbind(ID, asInteger(strsplit(ID_temp[i,])));
		}
	}
	
	// split panmictic population into N groups
	N = integerDiv(nInds, K);
	
	// dictionary associating the group number with the column number of the last common ancestor in ID
	lastCommonAncestor = Dictionary();
	lastCommonAncestor.setValue("1", 1);
	
	for (i in 2:N) {
		// initialize column of last common ancestor to 1 for every group
		lastCommonAncestor.setValue(asString(i), 1);
		
		// individuals are randomly split into groups
		migrants = p1.sampleIndividuals(K);
		
		newPop = community.subpopulationsWithIDs(i);
		newPop.takeMigrants(migrants);
	}
	
	sim.setValue('lastCommonAncestor', lastCommonAncestor);
	
	// attribute a growth rate to each group
	growthRate = rnorm(N, R, sigma);
	sim.setValue("growthRate", growthRate);
	
	// initialize number of extinctions
	sim.setValue("nExtinctions", 0);
	
	// initialize number of fissions
	sim.setValue("nFissions", 0);
	
	// record fission
	sim.setValue("fission", c()); // TO-DO : encore utile ?
	
	// counter of groups
	sim.setValue("counter", N);
	
	// make villages
	villages = Dictionary();
	// transform ID array in Dictionary associating an array per village
	ID_temp = Dictionary();
	groups = seq(1, N);
	firstGroupIndex = 0;
	NLIN = integerDiv(N, N_VILLAGES);  // number of groups per village
	SUP_LIN = integerMod(N, N_VILLAGES);  // number of supplementary groups
	for (i in seq(1, N_VILLAGES)) {
		name = paste0(c("V", asString(i)));  // village's name
		if (SUP_LIN > 0) {
			lastGroupIndex = firstGroupIndex + NLIN;
			SUP_LIN = SUP_LIN - 1;
		}
		else {
			lastGroupIndex = firstGroupIndex + NLIN - 1;
		}
		groupVillage = groups[firstGroupIndex : lastGroupIndex];  // vector of groups for village i
		villages.setValue(name, groupVillage);
		firstGroupIndex = lastGroupIndex + 1;
		
		if (RF == F) {
			ID_village = NULL;
			for (group in groupVillage) {
				group = sim.subpopulations[sim.subpopulations.id == group];
				inds = group.individuals;
				// list of pedigreeID of individuals in the village
				if (DESCENT == 'patrilineal') {
					indsID = inds[inds.sex == 'M'].pedigreeID;
				}
				else {
					indsID = inds[inds.sex == 'F'].pedigreeID;
				}
				for (id in indsID) {
					ID_village = rbind(ID_village, ID[which(ID[,0] == id),]);
				}
			}
			ID_temp.setValue(name, ID_village);
		}
	}
	
	// record villages
	sim.setValue("villages", villages);
	
	// set village initial size
	K_village = K * NLIN;
	sim.setValue("K_village", K_village);
	
	// record ID array
	if (RF == F) {
		sim.setValue("ID", ID_temp);
	}
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (group in villages.getValue(village)) {
			group = sim.subpopulations[sim.subpopulations.id == group];
			indGroup = group.individuals[group.individuals.age == 0];
			ind = c(ind, indGroup);
		}
		
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	// time between beginning of a group and fission event = group depth
	depth = Dictionary();
	for (i in seq(1, groups[lastGroupIndex])) {
		depth.setValue(asString(i), 0);
	}
	sim.setValue('depth', depth);
	
	sim.setValue('migrantRatioList', c());
	
	print("Elapsed (split groups + create villages) : " + (clock() - start));
}

1 first() {
	filename = paste0(c('bash_Num_replicat/Sim_', asString(MF_RATIO),'_bash_Num_replicat_gen_0.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

first() {
	// MIGRATION //
	print("MIGRATION");
	start = clock();
	
	// record adults
	adults = sim.subpopulations.individuals.pedigreeID;
	sim.setValue("adults", adults);
	
	villages = sim.getValue("villages");
	
	/// make lists of male and female migrants for each village ///
	migrantsF = Dictionary();
	migrantsM = Dictionary();
	for (key in villages.allKeys) {
		groupIDs = villages.getValue(key);
		groups = community.subpopulationsWithIDs(groupIDs);
		inds = groups.individuals;
		nInd = size(inds); // number of individuals
		IndF = inds[inds.sex=='F'];
		IndM = inds[inds.sex=='M'];
		nIndF = size(IndF); // number of females
		nIndM = size(IndM); // number of males
		
		nMigrantsF = asInteger(nInd * M_RATIO * MF_RATIO);  // number of female migrants
		nMigrantsM = asInteger(nInd * M_RATIO * (1-MF_RATIO));  // number of male migrants
		migrantsF.setValue(key, sample(IndF, nMigrantsF).pedigreeID);
		migrantsM.setValue(key, sample(IndM, nMigrantsM).pedigreeID);
	}
	
	for (key in villages.allKeys) {
		// migration in a new group from a different village
		for (migrant in migrantsF.getValue(key))  {
			// sample a village that is different from the migrant's village
			possibleVillages = setDifference(villages.allKeys, key);
			sampledVillage = sample(possibleVillages, 1);
			// sample a group in the sampled village
			possibleGroup = villages.getValue(sampledVillage);
			sampledGroup = sample(possibleGroup, 1);
			dest = community.subpopulationsWithIDs(sampledGroup);
			// migration happens between groups from different villages
			dest.takeMigrants(sim.individualsWithPedigreeIDs(migrant));
		}
		
		for (migrant in migrantsM.getValue(key))  {
			// sample a village that is different from the migrant's village
			possibleVillages = setDifference(villages.allKeys, key);
			sampledVillage = sample(possibleVillages, 1);
			// sample a group in the sampled village
			possibleGroup = villages.getValue(sampledVillage);
			sampledGroup = sample(possibleGroup, 1);
			dest = community.subpopulationsWithIDs(sampledGroup);
			// migration happens between groups from different villages
			dest.takeMigrants(sim.individualsWithPedigreeIDs(migrant));
		}
	}
	print("Elapsed (migration) : " + (clock() - start));
}

reproduction(NULL, NULL) {
	// REPRODUCTION //
	print("REPRODUCTION");
	start = clock();
	self.active = 0;  // "reproduction" is called once per generation
	
	groups = sim.subpopulations;
	inds = groups.individuals;
	nInds = size(inds);
	nIndsF = size(inds[inds.sex=='F']);  // number of females
	nIndsM = size(inds[inds.sex=='M']);  // number of males
	
	//// reproduction within each village ////
	
	growthRate = sim.getValue("growthRate");
	villages = sim.getValue("villages");
	depth = sim.getValue("depth");
	nExtinctions = sim.getValue("nExtinctions");
	
	// initialize number of couples	
	nCouples = 0;
	
	// initialize lists of mothers and fathers IDs
	mot = c();
	fat = c();
	
	// initialize number of males that cannot find a female in a different group
	failedCouples = 0;
	
	// initialize number of single individuals
	singleInd = 0;
	
	// initialize list of failed children
	failedChildren = c();
	
	// initialize list of couples
	couples = c();
	
	// initialize custom ID arrays for males and females
	if (RF == F) {
		ID = sim.getValue("ID");
		ID_2 = Dictionary();
	}
	
	for (key in villages.allKeys) {
		couplesVillage = c();  // same as couples but only for the current village
		if (RF == F) {
			ID_village = ID.getValue(key);
			ID_village_2 = NULL;  // temporary ID_village in order to update it at each generation
		}
		
		// list of individuals in the village
		groups = villages.getValue(key);
		inds = community.subpopulationsWithIDs(groups).individuals;
		
		// initialize number of children done
		nChildrenDone = 0;
		
		// lists of single males and females in the village
		availableM = inds[inds.sex == 'M'];
		availableF = inds[inds.sex == 'F'];
		
		/// form couples ///
		while (size(availableM) > 0 & size(availableF) > 0) {
			// choose a male
			husband = sample(availableM, 1);
			groupM = husband.subpopulation;
			
			// choose a female from a different group
			targetF = availableF[availableF.subpopulation != groupM];
			
			// if it is not possible, choose a female from the same group
			if (size(targetF)==0) {
				failedCouples = failedCouples + 1;
				wife = sample(availableF, 1);
			}
			else {
				wife = sample(targetF, 1);
			}
			
			// remove the couple from single males and females
			availableM = setDifference(availableM, c(husband));
			availableF = setDifference(availableF, c(wife));
			
			// update the list of couples in the group and initialize their number of children
			if (DESCENT == 'patrilineal') {
				couplesVillage = rbind(couplesVillage, c(key, husband.subpopulation.id, nCouples, husband.pedigreeID, wife.pedigreeID, 0));
			}
			else if (DESCENT == 'matrilineal') {
				couplesVillage = rbind(couplesVillage, c(key, wife.subpopulation.id, nCouples, husband.pedigreeID, wife.pedigreeID, 0));
			}
			nCouples = nCouples + 1;
		}
		
		// update single individuals
		singleInd = singleInd + size(availableM) + size(availableF);
		
		// Compute probabilities of reproduction
		groupCurrentGen = asInteger(unique(couplesVillage[,1]));
		growthRateVillage = sapply(groupCurrentGen, "growthRate[applyValue - 1];");
		
		print("Elapsed (reproduction villages, proba) : " + (clock() - start));
		start = clock();
		
		K_village = sim.getValue("K_village");
		K_village = asInteger(K_village * exp(R)); // exponential growth
		
		// initialize number of couples
		nCouples_done = 0;
		// compute breeding weights for each descent group
		index=0;
		if (DESCENT == 'patrilineal') {
			breedingWeights = sapply(groupCurrentGen, "index = index + 1;p = community.subpopulationsWithIDs(applyValue); 2 * size(p.individuals[p.individuals.sex == 'M']) * exp(growthRateVillage[index-1]);");
		}
		else if (DESCENT == 'matrilineal') {
			breedingWeights = sapply(groupCurrentGen, "index = index + 1;p = community.subpopulationsWithIDs(applyValue); 2 * size(p.individuals[p.individuals.sex == 'F']) * exp(growthRateVillage[index-1]);");
		}
		// sample K_village groups
		sampledGroup = sample(x = groupCurrentGen, size = K_village, replace = T, weights = breedingWeights);
		// sample 1 couple for each chosen group
		couplesIndex = sapply(sampledGroup, "sample(couplesVillage[which(couplesVillage[,1] == applyValue),][,2], 1);");
		sampledCouples = sapply(couplesIndex, "couplesVillage[which(couplesVillage[,2] == applyValue),][,3:4];");
		doneCouples = t(array(sapply(sampledCouples, "inds[inds.pedigreeID == applyValue];"), c(2, asInteger(size(sampledCouples)/2))));
		
		// active groups in the current generation
		groupCurrentGen = asInteger(unique(sampledGroup));
		
		// Compute number of extinctions
		extinctGroup = setDifference(groups, groupCurrentGen);
		nExt = size(extinctGroup);
		if (nExt > 0) {
			print('Extinction !');
			
			// update number of extinctions
			nExtinctions = nExtinctions + nExt;
			sim.setValue("nExtinctions", nExtinctions);
			
			// update villages
			villages.setValue(key, groupCurrentGen); // update key in villages
			
			// update depth
			for (keyExt in extinctGroup) {
				depth.setValue(asString(keyExt), NULL);
			}
			
			//update growth rates
			for (extGroup in extinctGroup) {
				extIndex = extGroup - 1;
				growthRate[extIndex] = -1;
			}
		}
		
		print("Elapsed (reproduction villages, form couples) : " + (clock() - start));
		start = clock();
		
		// initialize couple index
		coupleIndex = 0;
		
		// make K_village children //
		while (nChildrenDone < K_village) {
			// get father and mother
			father = c(doneCouples[coupleIndex, 0]);
			mother = c(doneCouples[coupleIndex, 1]);
			
			// choose the group of the father if patrilineal (or mother if matrilineal)
			// the child belongs to his father's group (patrilineal) or to his mother's group (matrilineal)
			pop = ifelse(DESCENT == 'patrilineal', father.subpopulation, mother.subpopulation);
			
			// make child
			// sex is defined so that the sex ratio = 0.5
			if (integerMod(coupleIndex, 2) == 0) {
				child = pop.addCrossed(mother, father, sex = 'F');
			}
			else {
				child = pop.addCrossed(mother, father, sex = 'M');
			}
			
			wrongSex = F;
			
			// females should not have a Y and have a mt and males should have a Y and not a mt
			if (child.genome2.containsMarkerMutation(m2, UpperXY)) {
				if (child.genome1.containsMarkerMutation(m3, UpperMt)) {
					failedChildren = c(failedChildren, child.pedigreeID);
					wrongSex = T;
				}
				else if (child.sex == 'F') {
					failedChildren = c(failedChildren, child.pedigreeID);
					wrongSex = T;
				}
			}
			else {
				if (!child.genome1.containsMarkerMutation(m3, UpperMt)) {
					failedChildren = c(failedChildren, child.pedigreeID);
					wrongSex = T;
				}
				else if (child.sex == 'M') {
					failedChildren = c(failedChildren, child.pedigreeID);
					wrongSex = T;
				}
			}
			
			if (wrongSex == F) {
				// increment couple index
				coupleIndex = coupleIndex + 1;
				
				// increment number of children for the couple
				nChildrenDone = nChildrenDone + 1;
				rowIndex = which(couplesVillage[,3] == father.pedigreeID);
				couplesVillage[rowIndex,5] = asInteger(couplesVillage[rowIndex,5]) + 1;
				
				// increment lists of mothers and fathers
				fat = unique(c(fat, father));
				mot = unique(c(mot, mother));
				
				// matrices of IDs
				if (RF == F) {
					if (DESCENT == 'matrilineal' & child.sex == 'F') {
						mother_ID = asString(mother.pedigreeID);
						// the daughter inherits the custom ID of her mother + supplementary number corresponding to the number of the child in the family
						ID_village_mother = ID_village[which(ID_village[,0] == mother_ID),];
						// if mother is a migrant, give the ID of another individual in the group
						while (size(ID_village_mother) == 0) {
							mother = mother.subpopulation.sampleIndividuals(1, exclude = mother);
							ID_village_mother = ID_village[which(ID_village[,0] == asString(mother.pedigreeID)),];
						}
						value = c(ID_village_mother, mother.reproductiveOutput - 1);
						ID_village_2 = rbind(ID_village_2, c(asString(child.pedigreeID), value[2:size(value)-1]));
					}
					else if (DESCENT == 'patrilineal' & child.sex == 'M') {
						father_ID = asString(father.pedigreeID);
						// the son inherits the custom ID of his father + supplementary number corresponding to the number of the child in the family
						ID_village_father = ID_village[which(ID_village[,0] == father_ID),];
						// if father is a migrant, give the ID of another individual in the group
						counter = 0;
						while (size(ID_village_father) == 0) {
							father = father.subpopulation.sampleIndividuals(1, exclude = father);
							ID_village_father = ID_village[which(ID_village[,0] == asString(father.pedigreeID)),];
							counter = counter + 1;
							if (counter > size(father.subpopulation.individuals[father.subpopulation.individuals.sex == 'M']) -1) {
								fatherID = sample(ID_village[,0], 1);
								ID_village_father = ID_village[which(ID_village[,0] == fatherID),];
							}
						}
						value = c(ID_village_father, father.reproductiveOutput - 1);
						ID_village_2 = rbind(ID_village_2, c(asString(child.pedigreeID), value[2:size(value)-1]));
					}
				}
			}
		}
		
		// extinction of non reproductive groups
		reproGroup = asInteger(unique(couplesVillage[,1]));
		extinctGroup = setDifference(groupCurrentGen, reproGroup);
		nExt = size(extinctGroup);
		if (nExt > 0) {
			print('Extinction !');
			
			// update number of extinctions
			nExtinctions = nExtinctions + nExt;
			sim.setValue("nExtinctions", nExtinctions);
			
			// update villages
			villages.setValue(key, reproGroup);
			
			// update depth
			for (keyExt in extinctGroup) {
				depth.setValue(asString(keyExt), NULL);
			}
			
			//update growth rates
			for (extGroup in extinctGroup) {
				extIndex = extGroup - 1;
				growthRate[extIndex] = -1;
			}
		}
		// update couples
		couples = rbind(couples, couplesVillage);
		if (RF == F) {
			ID_2.setValue(key, ID_village_2);
		}
		print("Elapsed (reproduction villages, make children) : " + (clock() - start));
		start = clock();
		
		// output demographic metrics
		groups = villages.getValue(key);
		pGroup = sapply(groups, "growthRate[applyValue - 1];");
		denom = sum(pGroup);
		proba = pGroup/denom;
		for (i in seq(0, size(groups) - 1)) {
			couplesGroup = couples[which(couples[,1] == groups[i]),];
			if (size(couplesGroup) == 0) {
				nChildGroup = 0;
			}
			else {
				nChildGroup = sum(asInteger(couplesGroup[,5]));
			}
			group = community.subpopulationsWithIDs(groups[i]);
			if (DESCENT == 'patrilineal') {
				sizeGroup = 2*size(group.individuals[group.individuals.sex == 'M']);
			}
			else if (DESCENT == 'matrilineal') {
				sizeGroup = 2*size(group.individuals[group.individuals.sex == 'F']);
			}

		}
	}
	
	for (i in seq(0, size(couples[,0])-1)) {
		couple = couples[i,];
		nChildren = asInteger(couple[,5]);
		group = couple[,1];
		line = paste("bash_Num_replicat", community.tick, group, nChildren);
		writeFile(paste0(output, "nChildrenPerCouple.txt"), line, append = T);
	}
	
	// increment group depth
	newDepth = depth;
	keys = sapply(depth.allKeys, "newDepth.setValue(applyValue, depth.getValue(applyValue) + 1); applyValue;");
	sim.setValue("depth", newDepth);
	
	mothers = size(mot)/nIndsF*100;
	fathers = size(fat)/nIndsM*100;
	nCouples = size(mot);
	sim.setValue('mothers', mothers);
	sim.setValue('fathers', fathers);
	sim.setValue('failedCouples', failedCouples);
	sim.setValue('%singleInd', singleInd/nInds * 100);
	sim.setValue('failedChildren', failedChildren);
	sim.setValue('nCouples', nCouples);
	sim.setValue('couples', couples);
	if (RF == F) {
		sim.setValue("ID", ID_2);
	}
	sim.setValue("villages", villages);
	sim.setValue("K_village", K_village);
	sim.setValue("growthRate", growthRate);
}

early() {
	//non-overlapping generations : we kill parents
	inds = sim.subpopulations.individuals;
	adults = sim.getValue("adults");
	if (!isNULL(adults)) {
		sim.killIndividuals(sim.individualsWithPedigreeIDs(adults));
	}
	
	// kill failed children
	failedChildren = sim.getValue("failedChildren");
	if (!isNULL(failedChildren)) {
		sim.killIndividuals(sim.individualsWithPedigreeIDs(failedChildren));
	}
}

20001:20100 early() {
	// FISSIONS / EXTINCTIONS //
	print("FISSIONS / EXTINCTIONS");
	start = clock();
	
	counter = sim.getValue("counter");
	nFissions = sim.getValue("nFissions");
	nExtinctions = sim.getValue("nExtinctions");
	villages = sim.getValue("villages");
	if (RF == F) {
		ID = sim.getValue("ID");
		groupDepth = c();
	}
	growthRate = sim.getValue("growthRate");
	depth = sim.getValue("depth");
	migrantRatioList = sim.getValue('migrantRatioList');
	K_village = sim.getValue('K_village');
	fissionTime = c();
	
	for (village in villages.allKeys) {
		pops = community.subpopulationsWithIDs(asInteger(villages.getValue(village)));
		nIndsM = size(pops.individuals[pops.individuals.sex == 'M']); // nb of males in the village
		
		if (RF == F) {
			ID_village = ID.getValue(village);
		}
		
		if (V == T) {
			nGroup = size(pops);
			nDeathsGroup = Dictionary();
			rho = e /((nGroup - 1) * sqrt(1/(2 * nGroup) * K_village));
			// rho = e/(nGroup-1); // higher deathRate for small groups
		}
		
		for (subpop in pops) {
			inds = subpop.individuals;
			nInds = size(inds);
			nMales = size(inds[inds.sex == 'M']); // nb of males in the descent group
			
			// fission event if the size of the descent group is above FITH and if the last fission event is older than 3 generations
			if (nInds >= FITH & depth.getValue(asString(subpop.id)) > 3) {
			//if (nInds >= FITH) {
				print("Fission !");
				nFissions = nFissions + 1;
				
				// update depth and counter
				fissionTime = c(fissionTime, depth.getValue(asString(subpop.id)));
				depth.setValue(asString(subpop.id), 0);
				counter = counter + 1;
				depth.setValue(asString(counter), 0);
				
				// modify growth rates for the resulting groups
				if (TM == "half") {
					newGrowthRate = rnorm(1, growthRate[subpop.id - 1], sigma);
					growthRate[subpop.id - 1] = newGrowthRate;
					growthRate = c(growthRate, rnorm(1, R, 0.1));
				}
				
				else {
					newGrowthRate = rnorm(1, growthRate[subpop.id - 1], sigma);
					growthRate[subpop.id - 1] = rnorm(1, growthRate[subpop.id - 1], sigma);
					growthRate = c(growthRate, newGrowthRate);
				}
				
				if (DESCENT == 'patrilineal') {
					ind = inds[inds.sex == 'M'];
					oppositSexInd = inds[inds.sex == 'F'];
				}
				else if (DESCENT == 'matrilineal') {
					ind = inds[inds.sex == 'F'];
					oppositSexInd = inds[inds.sex == 'M'];
				}
				
				/// lineal fission ///
				if (RF == F) {
					lastCommonAncestor = sim.getValue('lastCommonAncestor');
					
					// new ID matrix for individuals of the group
					new_ID = NULL;
					// reduce the number of values in ID vector : keep only generations where there are different ancestors
					for (id in ind.pedigreeID) {
						ID_village_individual = ID_village[which(ID_village[,0] == id),];
						// if ind is a migrant, it is not in ID_village
						if (size(ID_village_individual) == 0) {
							next;
						}
						new_ID = rbind(new_ID, ID_village[which(ID_village[,0] == id),]);
					}
					
					// find last common ancestor for the group
					idx = lastCommonAncestor.getValue(asString(subpop.id));
					ancestors = unique(new_ID[,idx]);
					nAncestors = size(ancestors);
					while (nAncestors == 1 & idx <= size(new_ID[0,])) {
						ancestors = unique(new_ID[,idx]);
						nAncestors = size(ancestors);
						idx = idx + 1;
						if (nAncestors > 1) {
							idx = idx - 1;
						}
					}
					
					// update group depth
					groupDepth = c(groupDepth, size(new_ID[0,]) - idx);
					
					// update lastCommonAncestor
					lastCommonAncestor.setValue(asString(subpop.id), idx);
					
					// initialize new groups
					group1 = c();
					group2 = c();
					
					// initialize number of descendants for each new group
					nGroup1 = 0;
					nGroup2 = 0;
					nDescendants = c();
					
					for (ancestor in ancestors) {
						nDescendants = c(nDescendants, size(which(new_ID[,idx] == ancestor)));
					}
					ordered_ancestors = order(nDescendants, ascending = F);
					
					for (index in ordered_ancestors) {
						if (nGroup1 <= nGroup2) {
							group1 = c(group1, new_ID[which(new_ID[,idx] == ancestors[index]),][,0]);
							nGroup1 = nGroup1 + nDescendants[index];
						}
						else {
							group2 = c(group2, new_ID[which(new_ID[,idx] == ancestors[index]),][,0]);
							nGroup2 = nGroup2 + nDescendants[index];
						}
					}
					group_number = sample(c(1,2), 1);
					if (group_number == 1) {
						newGroup = group1;
					}
					else {
						newGroup = group2;
					}
					migrants = sim.individualsWithPedigreeIDs(asInteger(newGroup));
					ratio_migrants = size(migrants)/(nGroup1 + nGroup2);
					
					// add individuals of opposite sex to migrants
					companions = sample(oppositSexInd, asInteger(ratio_migrants*size(oppositSexInd)));
					migrants = c(migrants, companions);
					
					//update lastCommonAncestor
					nCol = lastCommonAncestor.getValue(asString(subpop.id));
					lastCommonAncestor.setValue(asString(counter), nCol);
					sim.setValue('lastCommonAncestor', lastCommonAncestor);
				}
				
				/// random fission ///
				else {
					// we draw a number of migrants
					nInd = size(ind);
					nMigrants = asInteger(0.5*nInd);
					migrants = sample(ind, nMigrants);
					ratio_migrants = nMigrants/nInd;
					
					// add individuals of opposite sex to migrants
					companions = sample(oppositSexInd, asInteger(ratio_migrants*size(oppositSexInd)));
					migrants = c(migrants, companions);
				}
				
				migrantRatioList = c(migrantRatioList, ratio_migrants);
				
				// migration in a new group
				group = community.subpopulationsWithIDs(counter);
				group.takeMigrants(migrants);
				
				// update villages
				// if fission is friendly, the new group stays in the same village
				if (FF == T) {
					newGroup = Dictionary(village, c(counter));
				}
				
				// if fission is not friendly, the new group goes to another village
				else {
					// sample a village
					newVillage = sample(setDifference(villages.allKeys, village), 1);
					
					newGroup = Dictionary(newVillage, c(counter));
					
					if (RF == F) {
						// update ID
						ID_newVillage = ID.getValue(newVillage);
						for (ind in asInteger(newGroup)) {
							ID_newVillage = rbind(ID_newVillage, ID_village[which(ID_village[,0] == ind),]);
							ID_village = ID_village[which(ID_village[,0] != ind),];
						}
						ID.setValue(village, ID_village);
						ID.setValue(newVillage, ID_newVillage);
						sim.setValue("ID", ID);
					}
				}
				
				// add new group to its parent or new village
				villages.appendKeysAndValuesFrom(newGroup);
				
				// record fission
				fission = sim.getValue("fission");
				source = subpop.id;
				new = counter;
				fission = rbind(c(source, new), fission);
				
				sim.setValue("counter", counter);
				sim.setValue("fission", fission);
			}
			
			/// extinction (descent group without males) ///
			if (nMales == 0) {
				print('Extinction!');
				
				nExtinctions = nExtinctions + 1;
				
				// include remaining females in another group if necessary
				remainingInds = subpop.individuals;
				if (size(remainingInds) > 0) {
					possibleGroups = setDifference(pops, subpop);
					newGroup = sample(possibleGroups, 1);
					newGroup.takeMigrants(remainingInds);
				}
				
				// update villages
				groupID = villages.getValue(village);
				groups = setDifference(groupID, subpop.id);
				villages.setValue(village, groups);
				
				// update depth and growthRate
				depth.setValue(asString(subpop.id), NULL);
				growthRate[subpop.id - 1] = -1;
			}
			
			// extinction due to violence between groups
			if (V == T) {
				// kill only males
				// condition : there are males in the group and in other groups of the village
				if (nMales > 0 & nIndsM - nMales > 0) {
					// number of deaths in the group so that the number of deaths is
					// proportionnately higher in smaller groups
					deathRate = (nIndsM - nMales) * rho * sqrt(nMales);
					// deathRate = (nIndsM - nMales) * rho; // higher deathRate for small groups
					nDeaths = rpois(n=1,lambda=deathRate);
					if (nDeaths > nMales) {
						nDeaths = nMales;
					}
					deadInds = subpop.sampleIndividuals(nDeaths, sex = 'M');
					sim.killIndividuals(deadInds);
					
					// extinction if there is no more individuals in the group
					if (nDeaths == nMales) {
						print("Extinction !");
						nExtinctions = nExtinctions + 1;
						
						// remove remaining females from subpop
						remainingInds = subpop.individuals;
						if (size(remainingInds) > 0) {
							sim.killIndividuals(remainingInds);
						}
						
						// update villages
						groupID = villages.getValue(village);
						groups = setDifference(groupID, subpop.id);
						villages.setValue(village, groups);
						
						// update depth and growth rate
						depth.setValue(asString(subpop.id), NULL);
						growthRate[subpop.id - 1] = -1;
					}
				}
			}
		}
	}
	
	/// remove unactive groups ///
	activeGroup = sim.subpopulations[sim.subpopulations.individualCount > 0];
	realGroup = c();
	for (village in villages.allKeys) {
		realGroup = c(realGroup, community.subpopulationsWithIDs(asInteger(villages.getValue(village))));
	}
	extinctGroup = setDifference(activeGroup, realGroup);
	for (group in extinctGroup) {
		group.removeSubpopulation();
	}
	
	sim.setValue("villages", villages);
	sim.setValue("depth", depth);
	sim.setValue("growthRate", growthRate);
	sim.setValue('migrantRatioList', migrantRatioList);
	sim.setValue('nFissions', nFissions);
	sim.setValue("nExtinctions", nExtinctions);
	if (RF == F) {
		sim.setValue("groupDepth", groupDepth);
	}
	sim.setValue("fissionTime", fissionTime);
	print("Elapsed (Fissions/Extinctions) : " + (clock() - start));
}

20001:20100	late() {
	/// output ///
	subpop = sim.subpopulations;
	
	if (community.tick % 2 == 0) {
		nIndTotal = sum(size(subpop.individuals));
		
		nGroups = size(subpop[subpop.individualCount > 0]);
		
		// Nb of fissions (cumulated)
		nFissions = sim.getValue("nFissions");
		
		// Nb of extinctions (cumulated)
		nExtinctions = sim.getValue("nExtinctions");
		
		mothers = sim.getValue("mothers");
		fathers =  sim.getValue("fathers");
		indPerGroup = size(subpop.individuals)/nGroups;
		varIndPerGroup = var(subpop.individualCount/nGroups);
		femalePerGroup = size(subpop.individuals[subpop.individuals.sex == 'F'])/nGroups;
		failedCouples = sim.getValue("failedCouples");
		singleInd = sim.getValue("%singleInd");
		couples = sim.getValue("couples");
		meanNbChild = mean(c(asInteger(couples[,5])));
		varNbChild = var(c(asInteger(couples[,5])));
		
		// time between 2 fission events
		fissionTime = sim.getValue("fissionTime");
		if (size(fissionTime) > 0) {
			meanFissionTime = mean(fissionTime);
			varFissionTime = var(fissionTime);
			for (i in fissionTime){
				line = paste("bash_Num_replicat", community.tick, i);
				writeFile(paste0(output, "fissionTime.txt"), line, append = T);
			}
		}
		else {
			meanFissionTime = NAN;
			varFissionTime = NAN;
		}
		
		if (RF == F) {
			groupDepth = sim.getValue("groupDepth");
			if (isNULL(groupDepth)) {
				meanDepth = NAN;
				varDepth = NAN;
			}
			else {
				meanDepth = mean(groupDepth);
				varDepth = var(groupDepth);
				for (d in groupDepth){
					line = paste("bash_Num_replicat", community.tick, d);
					writeFile(paste0(output, "groupDepth.txt"), line, append = T);
				}
			}
		}
		else {
			meanDepth = NAN;
			varDepth = NAN;
		}
		
		migrantRatioList = sim.getValue('migrantRatioList');
		if (size(migrantRatioList) == 0) {
			meanRatioMigrants = NAN;
			varRatioMigrants = NAN;
		}
		else {
			meanRatioMigrants = mean(migrantRatioList);
			varRatioMigrants = var(migrantRatioList);
		}
		
		line = paste("bash_Num_replicat", community.tick, nIndTotal, nFissions, nExtinctions, nGroups, fathers, indPerGroup, varIndPerGroup, femalePerGroup, mothers, failedCouples, singleInd, meanNbChild, varNbChild, meanDepth, varDepth, meanRatioMigrants, varRatioMigrants, meanFissionTime, varFissionTime);
		writeFile(paste0(output, "metrics.txt"), line, append = T);
	}
}


20020 late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (group in villages.getValue(village)) {
			group = sim.subpopulations[sim.subpopulations.id == group];
			indGroup = group.individuals[group.individuals.age == 0];
			ind = c(ind, indGroup);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_', asString(MF_RATIO),'_bash_Num_replicat_gen_20.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20040 late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (group in villages.getValue(village)) {
			group = sim.subpopulations[sim.subpopulations.id == group];
			indGroup = group.individuals[group.individuals.age == 0];
			ind = c(ind, indGroup);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_', asString(MF_RATIO),'_bash_Num_replicat_gen_40.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20060	late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (group in villages.getValue(village)) {
			group = sim.subpopulations[sim.subpopulations.id == group];
			indGroup = group.individuals[group.individuals.age == 0];
			ind = c(ind, indGroup);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_', asString(MF_RATIO),'_bash_Num_replicat_gen_60.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20080 late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (group in villages.getValue(village)) {
			group = sim.subpopulations[sim.subpopulations.id == group];
			indGroup = group.individuals[group.individuals.age == 0];
			ind = c(ind, indGroup);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_', asString(MF_RATIO),'_bash_Num_replicat_gen_80.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20100 late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (group in villages.getValue(village)) {
			group = sim.subpopulations[sim.subpopulations.id == group];
			indGroup = group.individuals[group.individuals.age == 0];
			ind = c(ind, indGroup);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_', asString(MF_RATIO),'_bash_Num_replicat_gen_100.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

/*
20150 late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (group in villages.getValue(village)) {
			group = sim.subpopulations[sim.subpopulations.id == group];
			indGroup = group.individuals[group.individuals.age == 0];
			ind = c(ind, indGroup);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_', asString(MF_RATIO),'_bash_Num_replicat_gen_150.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}
/*