initialize() {
	initializeSLiMModelType("nonWF");
	
	// record pedigrees
	initializeSLiMOptions(keepPedigrees = T);
	
	// output tree sequences
	initializeTreeSeq();
	
	// set mutation rate to 0
	// mutations will be added during the processing of the tree sequences
	initializeMutationRate(0);
	
	initializeSex("A");
	
	// number of villages
	defineConstant("N_VILLAGES", bash_Num_villages);
	
	// carrying capacity
	defineConstant("K", bash_carrying_capacity);
	
	// Nb of replicates
	defineConstant("N_REP", bash_Num_replicat);
	
	// chromosome sizes
	defineConstant("CHR_SIZE", bash_chr_size);
	
	// random fission
	defineConstant("RF", bash_random_fission);
	
	// fission threshold
	defineConstant("FITH", bash_fission_threshold);
	
	// friendly fission : lineages stay in the same village. If not, a lineage moves to another village
	defineConstant("FF", bash_friendly_fission);
	
	// violence
	defineConstant("V", bash_violence);
	
	// extinction rate
	defineConstant("e", bash_extinction_rate);
	
	// descent rule
	defineConstant("DESCENT", "bash_descent_rule");
	
	// migration rate
	defineConstant("M_RATIO", bash_migration_rate);
	
	// residence rule
	defineConstant("RES", "bash_residence_rule");
	
	// parameter of the gamma law used to draw growth rates
	defineConstant("sigma", bash_sigma);
	
	// growth rate
	defineConstant('R', bash_growth_rate);
	
	// transmission of growth rate to the new lineage
	defineConstant('TM', "bash_transmission");
	
	// output folder
	defineConstant('nameDir', "bash_namedir");
	
	// set neutral mutations and convert to substitution
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeMutationType("m2", 1.0, "f", 0.0); // Y marker
	initializeMutationType("m3", 1.0, "f", 0.0); // mt marker
	
	initializeMutationType("m4", 1.0, "f", 0.0); // village 1 marker
	initializeMutationType("m5", 1.0, "f", 0.0); // village 2 marker
	initializeMutationType("m6", 1.0, "f", 0.0); // village 3 marker	
	initializeMutationType("m7", 1.0, "f", 0.0); // village 4 marker	
	initializeMutationType("m8", 1.0, "f", 0.0); // village 5 marker	
	
	initializeGenomicElementType("g1", m1, 1.0);
	
	defineConstant("UpperA", CHR_SIZE[0]); // upper boundary for autosomes	
	defineConstant("LowerXY", CHR_SIZE[0] + 1); // lower boundary for X/Y chromosomes
	defineConstant("UpperXY", CHR_SIZE[0] + CHR_SIZE[1] + 2); // upper boundary for X/Y chromosomes	
	defineConstant("LowerMt", CHR_SIZE[0] + CHR_SIZE[1] + 3); // lower boundary for mtDNA
	defineConstant("UpperMt", CHR_SIZE[0] + CHR_SIZE[1] + CHR_SIZE[2] + 4); // upper boundary for mtDNA
	
	initializeGenomicElement(g1, 0, UpperMt);
	
	initializeRecombinationRate(c(1.1e-8, 0.5, 0, 0.5, 1e-8), c(UpperA, LowerXY, UpperXY, LowerMt, UpperMt), sex='M');
	initializeRecombinationRate(c(1.1e-8, 0.5, 1e-8, 0.5, 0), c(UpperA, LowerXY, UpperXY, LowerMt, UpperMt), sex='F');
	
	if (V == F) {
		defineConstant("output", paste0("~/Documents/SLiM_model/Tables/Simulations_metrics/unilineal/extended/r=", R, '/sigma=', sigma, '/FT=', FITH, '/',  nameDir, "/"));
	}
	else
		defineConstant("output", paste0("~/Documents/SLiM_model/Tables/Simulations_metrics/unilineal/extended/r=", R, '/sigma=', sigma, '/FT=', FITH, '/',  '/e=', e, '/', nameDir, "/"));
}

1 first() {
	start = clock();
	
	// load the burn-in simulation
	suppressWarnings(T);
	sim.readFromPopulationFile(paste0(c('~/Documents/SLiM_model/Burn_in/outgroup_villages_unilineal_descent_burn_in_', asString(N_REP), '.trees')));
	inds = p1.individuals;
	nInds = size(inds);
	
	// ancestors array
	if (RF == F) {
		if (DESCENT == 'patrilineal') {
			ID_temp = readFile(paste0(c('~/Documents/SLiM_model/Burn_in/patrilineal_ID_', asString(N_REP), '.txt')));
		}
		else {
			ID_temp = readFile(paste0(c('~/Documents/SLiM_model/Burn_in/matrilineal_ID_', asString(N_REP), '.txt')));
		}
		ID_temp = array(ID_temp, c(size(ID_temp), 1));
		ID = NULL;
		for (i in seq(0, nrow(ID_temp)-1)) {
			ID = rbind(ID, asInteger(strsplit(ID_temp[i,])));
		}
	}
	
	// split panmictic population into N lineages
	N = integerDiv(nInds, K);
	
	// dictionary associating the lineage number with the column number of the last common ancestor in ID
	lastCommonAncestor = Dictionary();
	lastCommonAncestor.setValue("1", 1);
	
	for (i in 2:N) {
		lastCommonAncestor.setValue(asString(i), 1);
		
		// individuals are randomly split into lineages
		migrants = p1.sampleIndividuals(K);
		
		new_pop = community.subpopulationsWithIDs(i);
		new_pop.takeMigrants(migrants);
	}
	
	sim.setValue('lastCommonAncestor', lastCommonAncestor);
	
	// attribute a growth rate to each lineage
	growthRate = rnorm(N, R, sigma);
	sim.setValue("growthRate", growthRate);
	
	// nb of extinctions
	sim.setValue("nExtinctions", 0);
	
	// nb of fissions
	sim.setValue("nFissions", 0);
	
	// record fission
	sim.setValue("fission", c());
	
	// counter of the nb of created lineages
	sim.setValue("counter", N);
	
	// make villages
	villages = Dictionary();
	// transform ID array in Dictionary associating an array per village
	ID_temp = Dictionary();
	lineages = seq(1, N);
	firstLinIndex = 0;
	NLIN = integerDiv(N, N_VILLAGES); // number of lineages per village
	SUP_LIN = integerMod(N, N_VILLAGES); // number of supplementary lineages
	for (i in seq(1, N_VILLAGES)) {
		name = paste0(c("V", asString(i))); // village's name
		if (SUP_LIN > 0) {
			lastLinIndex = firstLinIndex + NLIN;
			SUP_LIN = SUP_LIN - 1;
		}
		else {
			lastLinIndex = firstLinIndex + NLIN - 1;
		}
		linVillage = lineages[firstLinIndex : lastLinIndex]; // vector of lineages for village i
		villages.setValue(name, linVillage);
		firstLinIndex = lastLinIndex + 1;
		
		if (RF == F) {
			ID_village = NULL;
			for (lineage in linVillage) {
				lin = sim.subpopulations[sim.subpopulations.id == lineage];
				inds = lin.individuals;
				// list of pedigreeID of individuals in the village
				if (DESCENT == 'patrilineal') {
					indsID = inds[inds.sex == 'M'].pedigreeID;
				}
				else {
					indsID = inds[inds.sex == 'F'].pedigreeID;
				}
				for (id in indsID) {
					ID_village = rbind(ID_village, ID[which(ID[,0] == id),]);
				}
			}
			ID_temp.setValue(name, ID_village);
		}
	}
	
	// record villages
	sim.setValue("villages", villages);
	
	// set village initial size
	K_village = K * NLIN;
	sim.setValue("K_village", K_village);
	
	if (RF == F) {
		sim.setValue("ID", ID_temp);
	}
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (lineage in villages.getValue(village)) {
			lin = sim.subpopulations[sim.subpopulations.id == lineage];
			indLin = lin.individuals[lin.individuals.age == 0];
			ind = c(ind, indLin);
		}
		
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	// time between beginning of a lineage and fission event = lineage depth
	depth = Dictionary();
	for (i in seq(1, lineages[lastLinIndex])) {
		depth.setValue(asString(i), 0);
	}
	sim.setValue('depth', depth);
	
	sim.setValue('migrantRatioList', c());
	
	// female migration rate
	if (RES == "patrilocal") {
		sim.setValue("MF_RATIO", 1);
		//defineConstant("MF_RATIO", runif(1, 0.9, 1));
	}
	else {
		sim.setValue("MF_RATIO", 0);
		//defineConstant("MF_RATIO", runif(1, 0, 0.1));
	}
	
	print("Elapsed (split lineages + create villages) : " + (clock() - start));
}

1 first() {
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_0.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

first() {
	// MIGRATION //
	print("MIGRATION");
	start = clock();
	
	// record adults
	adults = sim.subpopulations.individuals.pedigreeID;
	sim.setValue("adults", adults);
	
	MF_RATIO = sim.getValue("MF_RATIO");
	villages = sim.getValue("villages");
	
	if (community.tick <= 20100) {
		/// make lists of male and female migrants for each village ///
		migrantsF = Dictionary();
		migrantsM = Dictionary();
		for (key in villages.allKeys) {
			groupIDs = villages.getValue(key);
			groups = community.subpopulationsWithIDs(groupIDs);
			inds = groups.individuals;
			nInd = size(inds); // number of individuals
			IndF = inds[inds.sex=='F'];
			IndM = inds[inds.sex=='M'];
			nIndF = size(IndF); // number of females
			nIndM = size(IndM); // number of males
			
			nMigrantsF = asInteger(nInd * M_RATIO * MF_RATIO);  // number of female migrants
			nMigrantsM = asInteger(nInd * M_RATIO * (1-MF_RATIO));  // number of male migrants
			migrantsF.setValue(key, sample(IndF, nMigrantsF).pedigreeID);
			migrantsM.setValue(key, sample(IndM, nMigrantsM).pedigreeID);
		}
		
		// migration in a new lineage from a different village //
		for (key in villages.allKeys) {
			for (migrant in migrantsF.getValue(key))  {
				// sample a village that is different from the migrant's village
				possibleVillages = setDifference(villages.allKeys, key);
				sampledVillage = sample(possibleVillages, 1);
				// sample a lineage in the sampled village
				possibleLin = villages.getValue(sampledVillage);
				sampledLin = sample(possibleLin, 1);
				dest = community.subpopulationsWithIDs(sampledLin);
				// migration happens between lineages from different villages
				dest.takeMigrants(sim.individualsWithPedigreeIDs(migrant));
			}
			
			for (migrant in migrantsM.getValue(key))  {
				// sample a village that is different from the migrant's village
				possibleVillages = setDifference(villages.allKeys, key);
				sampledVillage = sample(possibleVillages, 1);
				// sample a lineage in the sampled village
				possibleLin = villages.getValue(sampledVillage);
				sampledLin = sample(possibleLin, 1);
				dest = community.subpopulationsWithIDs(sampledLin);
				// migration happens between lineages from different villages
				dest.takeMigrants(sim.individualsWithPedigreeIDs(migrant));
			}
		}
	}
	else {
		// sex-specific migration 
		pops = sim.subpopulations[sim.subpopulations.individualCount > 0]; // select all villages
		inds = pops.individuals;
		nInd = size(inds); // nb of individuals
		IndF = inds[inds.sex == 'F'];
		IndM = inds[inds.sex == 'M'];
		
		if (MF_RATIO == 0)
			nMigrantsF = 0;
		else
			nMigrantsF = asInteger(nInd * M_RATIO * MF_RATIO); // nb of female migrants
		if (MF_RATIO == 1)
			nMigrantsM = 0;
		else
			nMigrantsM = asInteger(nInd * M_RATIO * (1-MF_RATIO)); // nb of male migrants
		migrantsF = sample(IndF, nMigrantsF);
		migrantsM = sample(IndM, nMigrantsM);
		
		// migration in a new village
		for (migrant in migrantsF)  {
			do dest = sample(pops, 1);
			while (dest == migrant.subpopulation);
			dest.takeMigrants(migrant);
		}
		for (migrant in migrantsM)  {
			do dest = sample(pops, 1);
			while (dest == migrant.subpopulation);
			dest.takeMigrants(migrant);
		}
	}
	print("Elapsed (migration) : " + (clock() - start));
}

reproduction(NULL, NULL) {
	// REPRODUCTION //
	print("REPRODUCTION");
	start = clock();
	self.active = 0;  // "reproduction" is called once per generation
	
	// initialize number of couples	
	nCouples = 0;
	
	// initialize lists of mothers and fathers IDs
	mot = c();
	fat = c();
	
	// initialize number of males that cannot find a female in a different lineage
	failedCouples = 0;
	
	// initialize list of couples
	couples = c();
	
	// initialize list of failed children
	failedChildren = c();
	
	if (community.tick <= 20100) {
		lineages = sim.subpopulations; // select all lineages
		inds = lineages.individuals; // only individuals of the current generation can have children
		print(lineages.individualCount[lineages.individualCount > 0]);
		nindsF = size(inds[inds.sex=='F']); // nb of women
		nMales = size(inds[inds.sex=='M']); // nb of men
		
		// reproduction within each village
		growthRate = sim.getValue("growthRate");
		villages = sim.getValue("villages");
		nExtinctions = sim.getValue("nExtinctions");
		depth = sim.getValue("depth");
		
		
		// initialize custom IDs for males and females
		if (RF == F) {
			ID = sim.getValue("ID");
			ID_2 = Dictionary();
		}
		
		for (key in villages.allKeys) {
			print(key);
			inds = c();
			couplesVillage = c(); // same as couples but only for the current village
			if (RF == F) {
				ID_village = ID.getValue(key);
				ID_village_2 = NULL; // temporary ID_village in order to update it at each generation
			}
			
			lineages = villages.getValue(key);
			inds = community.subpopulationsWithIDs(lineages).individuals; // list of individuals in the village
			
			if (size(inds) == 0) {
				next;
			}
			
			// initialize number of children done
			nChildrenDone = 0;
			
			availableM = inds[inds.sex == 'M']; // list of single men in the village
			availableF = inds[inds.sex == 'F']; // list of single women in the village
			
			// form couples
			while (size(availableM) > 0 & size(availableF) > 0) {
				// choose a man
				husband = sample(availableM, 1);
				linM = husband.subpopulation;
				
				// choose a woman from a different lineage
				targetF = availableF[availableF.subpopulation != linM];
				
				// if it is not possible, choose a woman from the same lineage
				if (size(targetF)==0) {
					//print('no target women');
					failedCouples = failedCouples + 1;
					wife = sample(availableF, 1);
				}
				else {
					wife = sample(targetF, 1);
				}
				
				// remove the couple from single men and women
				availableM = setDifference(availableM, c(husband));
				availableF = setDifference(availableF, c(wife));
				
				// update the list of couples in the lineage and initialize their number of children
				if (DESCENT == 'patrilineal') {
					couplesVillage = rbind(couplesVillage, c(key, husband.subpopulation.id, nCouples, husband.pedigreeID, wife.pedigreeID, 0));
				}
				else if (DESCENT == 'matrilineal') {
					couplesVillage = rbind(couplesVillage, c(key, wife.subpopulation.id, nCouples, husband.pedigreeID, wife.pedigreeID, 0));
				}
				nCouples = nCouples + 1;
			}
			
			// Compute probabilities of reproduction
			linCurrentGen = asInteger(unique(couplesVillage[,1]));
			growthRateVillage = sapply(linCurrentGen, "growthRate[applyValue - 1];");
			
			print("Elapsed (reproduction villages, proba) : " + (clock() - start));
			start = clock();
			
			K_village = sim.getValue("K_village");
			K_village = asInteger(K_village * exp(R));
			
			// Form couples //
			
			// initialize number of couples
			nCouples_done = 0;
			// compute breeding weights for each descent group
			index=0;
			if (DESCENT == 'patrilineal') {
				breedingWeights = sapply(linCurrentGen, "index = index + 1;p = community.subpopulationsWithIDs(applyValue); 2 * size(p.individuals[p.individuals.sex == 'M']) * exp(growthRateVillage[index-1]);");
			}
			else if (DESCENT == 'matrilineal') {
				breedingWeights = sapply(linCurrentGen, "index = index + 1;p = community.subpopulationsWithIDs(applyValue); 2 * size(p.individuals[p.individuals.sex == 'F']) * exp(growthRateVillage[index-1]);");
			}
			// sample K_village lineages with replacement
			sampledLin = sample(x = linCurrentGen, size = K_village, replace = T, weights = breedingWeights);
			// sample 1 couple for each chosen lineage
			couplesIndex = sapply(sampledLin, "sample(couplesVillage[which(couplesVillage[,1] == applyValue),][,2], 1);");
			sampledCouples = sapply(couplesIndex, "couplesVillage[which(couplesVillage[,2] == applyValue),][,3:4];");
			doneCouples = t(array(sapply(sampledCouples, "inds[inds.pedigreeID == applyValue];"), c(2, asInteger(size(sampledCouples)/2))));
			
			// Lineages in the simulation in the current generation
			linCurrentGen = asInteger(unique(sampledLin));
			
			// Compute number of extinctions
			extinctLin = setDifference(lineages, linCurrentGen);
			nExt = size(extinctLin);
			if (nExt > 0) {
				print('Extinction !');
				
				// update number of extinctions
				nExtinctions = nExtinctions + nExt;
				sim.setValue("nExtinctions", nExtinctions);
				
				// update villages
				villages.setValue(key, linCurrentGen); // update key in villages
				
				// update depth
				for (keyExt in extinctLin) {
					depth.setValue(asString(keyExt), NULL);
				}
				
				//update growth rates
				for (extLin in extinctLin) {
					extIndex = extLin - 1;
					growthRate[extIndex] = -1;
				}
			}
			
			print("Elapsed (reproduction villages, form couples) : " + (clock() - start));
			start = clock();
			
			// initialize couple index
			coupleIndex = 0;
			
			// make K_village children //
			while (nChildrenDone < K_village) {
				// get father and mother
				father = c(doneCouples[coupleIndex, 0]);
				mother = c(doneCouples[coupleIndex, 1]);
				
				// choose the lineage of the father if patrilineal (or mother if matrilineal)
				// the child belongs to his father's lineage (patrilineal) or to his mother's lineage (matrilineal)
				pop = ifelse(DESCENT == 'patrilineal', father.subpopulation, mother.subpopulation);
				
				// make child
				// sex is defined so that the sex ratio = 0.5
				if (integerMod(coupleIndex, 2) == 0) {
					child = pop.addCrossed(mother, father, sex = 'F');
				}
				else {
					child = pop.addCrossed(mother, father, sex = 'M');
				}
				
				wrongSex = F;
				
				// females should not have a Y and have a mito and males should have a Y and not a mito
				if (child.genome2.containsMarkerMutation(m2, UpperXY)) {
					if (child.genome1.containsMarkerMutation(m3, UpperMt)) {
						failedChildren = c(failedChildren, child.pedigreeID);
						wrongSex = T;
					}
					else if (child.sex == 'F') {
						child.fitnessScaling = 0;
						wrongSex = T;
					}
				}
				else {
					if (!child.genome1.containsMarkerMutation(m3, UpperMt)) {
						failedChildren = c(failedChildren, child.pedigreeID);
						wrongSex = T;
					}
					else if (child.sex == 'M') {
						failedChildren = c(failedChildren, child.pedigreeID);
						wrongSex = T;
					}
				}
				
				if (wrongSex == F) {
					// increment couple index
					coupleIndex = coupleIndex + 1;
					
					// increment number of children for the couple
					nChildrenDone = nChildrenDone + 1;
					rowIndex = which(couplesVillage[,3] == father.pedigreeID);
					couplesVillage[rowIndex,5] = asInteger(couplesVillage[rowIndex,5]) + 1;
					
					// increment lists of mothers and fathers
					fat = unique(c(fat, father));
					mot = unique(c(mot, mother));
					
					// matrices of IDs
					if (RF == F) {
						if (DESCENT == 'matrilineal' & child.sex == 'F') {
							mother_ID = asString(mother.pedigreeID);
							// the daughter inherits the custom ID of her mother + supplementary number corresponding to the number of the child in the family
							value = c(ID_village[which(ID_village[,0] == mother_ID),], mother.reproductiveOutput - 1);
							ID_village_2 = rbind(ID_village_2, c(asString(child.pedigreeID), value[1:(size(value)-1)]));
						}
						else if (DESCENT == 'patrilineal' & child.sex == 'M') {
							father_ID = asString(father.pedigreeID);
							// the son inherits the custom ID of his father + supplementary number corresponding to the number of the child in the family
							value = c(ID_village[which(ID_village[,0] == father_ID),], father.reproductiveOutput - 1);
							print(size(value));
							ID_village_2 = rbind(ID_village_2, c(asString(child.pedigreeID), value[1:(size(value)-1)]));
						}
					}
				}
			}
			// extinction of non reproductive lineages
			reproLin = asInteger(unique(couplesVillage[,1]));
			extinctLin = setDifference(linCurrentGen, reproLin);
			nExt = size(extinctLin);
			if (nExt > 0) {
				print('Extinction !');
				
				nExtinctions = nExtinctions + nExt;
				sim.setValue("nExtinctions", nExtinctions);
				
				// update villages
				villages.setValue(key, reproLin);
				print(villages);
				
				// update depth
				for (keyExt in extinctLin) {
					depth.setValue(asString(keyExt), NULL);
				}
				
				//update growth rates
				for (extLin in extinctLin) {
					extIndex = extLin - 1;
					growthRate[extIndex] = -1;
				}
			}
			// update couples
			couples = rbind(couples, couplesVillage);
			if (RF == F) {
				ID_2.setValue(key, ID_village_2);
			}
		}
		
		print("Elapsed (reproduction villages, make children) : " + (clock() - start));
		start = clock();
		
		sim.setValue('failedCouples', failedCouples);
		sim.setValue("growthRate", growthRate);
		
		// increment lineage depth
		newDepth = depth;
		keys = sapply(depth.allKeys, "newDepth.setValue(applyValue, depth.getValue(applyValue) + 1); applyValue;");
		sim.setValue("depth", newDepth);
		
		sim.setValue('couples', couples);
		if (RF == F) {
			sim.setValue("ID", ID_2);
		}
		sim.setValue("villages", villages);
	}
	
	else {
		
		nChildrenPerCouple = Dictionary();
		lineages = sim.subpopulations; // select all lineages except outgroup
		inds = lineages.individuals; // only individuals of the current generation can have children
		print(lineages.individualCount[lineages.individualCount > 0]);
		nindsF = size(inds[inds.sex=='F']); // nb of women
		nMales = size(inds[inds.sex=='M']); // nb of men
		
		for (pop in sim.subpopulations) {
			if (pop.individualCount != 0) {
				print(pop.id);
				nChildrenDone = 0;
				inds = pop.individuals;
				indsF = inds[inds.sex=='F'];
				indsM = inds[inds.sex=='M'];
				sizeF = size(indsF); // nb of women
				sizeM = size(indsM); // nb of men
				
				// maximum nb of couples
				size = min(sizeF, sizeM);
				
				// shuffle women and men in lists
				indsF = pop.sampleIndividuals(size, sex = 'F');
				indsM = pop.sampleIndividuals(size, sex='M');
				
				// initialize nChildrenPerCouple for each couple
				for (i in seq(0, size)) {
					nChildrenPerCouple.setValue(asString(nCouples + i), 0);
				}
				
				// make K_village children
				K_village = sim.getValue("K_village");
				K_village = asInteger(K_village * exp(R));
				
				while (nChildrenDone < K_village) {
					
					// random draw
					index = asInteger(runif(1,0,size));
					
					// make child
					father = indsM[index]; // we take the father
					mother = indsF[index]; // we take the mother
					
					// alternate sex
					if (integerMod(nChildrenDone, 2) == 0) {
						sex = "M";
					}
					else {
						sex = "F";
					}
					
					child = pop.addCrossed(mother, father, sex = sex);	// make child
					wrongSex = F;
					
					// females should not have a Y and have a mito and males should have a Y and not a mito
					if (child.genome2.containsMarkerMutation(m2, UpperXY)) {
						if (child.genome1.containsMarkerMutation(m3, UpperMt)) {
							failedChildren = c(failedChildren, child.pedigreeID);
							wrongSex = T;
						}
						else if (child.sex == 'F') {
							failedChildren = c(failedChildren, child.pedigreeID);
							wrongSex = T;
						}
					}
					else {
						if (!child.genome1.containsMarkerMutation(m3, UpperMt)) {
							failedChildren = c(failedChildren, child.pedigreeID);
							wrongSex = T;
						}
						else if (child.sex == 'M') {
							failedChildren = c(failedChildren, child.pedigreeID);
							wrongSex = T;
						}
					}
					
					if (wrongSex == F) {
						nChildrenDone = nChildrenDone + 1; // increase the total nb of children
						// update nChildrenPerCouple
						nChildren = nChildrenPerCouple.getValue(asString(nCouples + index));
						nChildren = nChildren + 1;
						nChildrenPerCouple.setValue(asString(nCouples + index), nChildren);
						// increment lists of mothers and fathers
						fat = unique(c(fat, father));
						mot = unique(c(mot, mother));
					}
				}
				nCouples = nCouples + size;
			}
		}
		sim.setValue("nChildrenPerCouple", nChildrenPerCouple);
	}
	
	mothers = size(mot)/nindsF*100;
	fathers = size(fat)/nMales*100;
	nCouples = size(mot);
	sim.setValue('mothers', mothers);
	sim.setValue('fathers', fathers);
	sim.setValue('nCouples', nCouples);
	sim.setValue("K_village", K_village);
	sim.setValue('failedChildren', failedChildren);
}


early() {
	//non-overlapping generations : we kill parents
	inds = sim.subpopulations.individuals;
	adults = sim.getValue("adults");
	if (!isNULL(adults)) {
		sim.killIndividuals(sim.individualsWithPedigreeIDs(adults));
	}
	
	// kill failed children
	failedChildren = sim.getValue("failedChildren");
	if (!isNULL(failedChildren)) {
		sim.killIndividuals(sim.individualsWithPedigreeIDs(failedChildren));
	}
}

early() {
	if (community.tick <= 20100) {
		// FISSIONS / EXTINCTIONS //
		print('FISSION/EXTINCTION');
		start = clock();
		
		counter = sim.getValue("counter");
		nFissions = sim.getValue("nFissions");
		nExtinctions = sim.getValue("nExtinctions");
		villages = sim.getValue("villages");
		if (RF == F) {
			ID = sim.getValue("ID");
			linDepth = c();
		}
		
		growthRate = sim.getValue("growthRate");
		depth = sim.getValue("depth");
		migrantRatioList = sim.getValue('migrantRatioList');
		
		for (village in villages.allKeys) {
			print(villages);
			pops = community.subpopulationsWithIDs(asInteger(villages.getValue(village)));
			nIndsM = size(pops.individuals[pops.individuals.sex == 'M']);
			
			if (RF == F) {
				ID_village = ID.getValue(village);
			}
			
			if (V == T) {
				nLin = size(pops);
				nDeathsLin = Dictionary();
				rho = e /((nLin - 1) * sqrt(1/(2 * nLin) * K_village));
			}
			
			for (subpop in pops) {
				inds = subpop.individuals;
				nInds = size(inds);
				nMales = size(inds[inds.sex == 'M']);
				
				// fission event if the lineage size is above FITH and if the last fission event is older than 9 generations
				if (nInds >= FITH & depth.getValue(asString(subpop.id)) > 3) {
					print("Fission !");
					nFissions = nFissions + 1;
					
					depth.setValue(asString(subpop.id), 0);
					counter = counter + 1;
					depth.setValue(asString(counter), 0);
					
					if (TM == "half") {
						newGrowthRate = rnorm(1, growthRate[subpop.id - 1], sigma);
						growthRate[subpop.id - 1] = newGrowthRate;
						growthRate = c(growthRate, rnorm(1, R, 0.1));
					}
					
					else {
						newGrowthRate = rnorm(1, growthRate[subpop.id - 1], sigma);
						growthRate[subpop.id - 1] = rnorm(1, growthRate[subpop.id - 1], sigma);
						growthRate = c(growthRate, newGrowthRate);
					}
					
					if (DESCENT == 'patrilineal') {
						ind = inds[inds.sex == 'M'];
						oppositSexInd = inds[inds.sex == 'F'];
					}
					else if (DESCENT == 'matrilineal') {
						ind = inds[inds.sex == 'F'];
						oppositSexInd = inds[inds.sex == 'M'];
					}
					
					/// lineal fission ///
					if (RF == F) {
						lastCommonAncestor = sim.getValue('lastCommonAncestor');
						
						// new ID matrix for individuals of the lineage
						new_ID = NULL;
						// reduce the number of values in ID vector : keep only generations where there are different ancestors
						for (id in ind.pedigreeID) {
							new_ID = rbind(new_ID, ID_village[which(ID_village[,0] == id),]);
						}
						
						// find last common ancestor for the new lineage
						idx = lastCommonAncestor.getValue(asString(subpop.id));
						ancestors = unique(new_ID[,idx]);
						nAncestors = size(ancestors);
						while (nAncestors == 1) {
							ancestors = unique(new_ID[,idx]);
							nAncestors = size(ancestors);
							idx = idx + 1;
							if (nAncestors > 1) {
								idx = idx - 1;
							}
						}
						
						// update lineage depth
						linDepth = c(linDepth, size(new_ID[0,]) - idx);
						
						// update lastCommonAncestor
						lastCommonAncestor.setValue(asString(subpop.id), idx);
						
						// initialize new lineages
						lin1 = c();
						lin2 = c();
						
						// initialize nb of descendants for each new lineage
						nLin1 = 0;
						nLin2 = 0;
						nDescendants = c();
						
						for (ancestor in ancestors) {
							nDescendants = c(nDescendants, size(which(new_ID[,idx] == ancestor)));
						}
						ordered_ancestors = order(nDescendants, ascending = F);
						
						for (index in ordered_ancestors) {
							if (nLin1 <= nLin2) {
								lin1 = c(lin1, new_ID[which(new_ID[,idx] == ancestors[index]),][,0]);
								nLin1 = nLin1 + nDescendants[index];
							}
							else {
								lin2 = c(lin2, new_ID[which(new_ID[,idx] == ancestors[index]),][,0]);
								nLin2 = nLin2 + nDescendants[index];
							}
						}
						lin_nb = sample(c(1,2), 1);
						if (lin_nb == 1) {
							newLin = lin1;
						}
						else {
							newLin = lin2;
						}
						migrants = sim.individualsWithPedigreeIDs(asInteger(newLin));
						ratio_migrants = size(migrants)/(nLin1 + nLin2);
						
						// add individuals of opposite sex to migrants
						companions = sample(oppositSexInd, asInteger(ratio_migrants*size(oppositSexInd)));
						migrants = c(migrants, companions);
						
						//update lastCommonAncestor
						nCol = lastCommonAncestor.getValue(asString(subpop.id));
						lastCommonAncestor.setValue(asString(counter), nCol);
						sim.setValue('lastCommonAncestor', lastCommonAncestor);
					}
					
					// random fission
					else {
						// we draw a number of migrants
						nInd = size(ind);
						nMigrants = asInteger(0.5*nInd);
						migrants = sample(ind, nMigrants);
						ratio_migrants = nMigrants/nInd;
						
						// add individuals of opposite sex to migrants
						companions = sample(oppositSexInd, asInteger(ratio_migrants*size(oppositSexInd)));
						migrants = c(migrants, companions);
					}
					
					migrantRatioList = c(migrantRatioList, ratio_migrants);
					
					// migration in a new lineage
					lineage = sim.subpopulations[sim.subpopulations.id == counter];
					lineage.takeMigrants(migrants);
					
					// update villages
					// if fission is friendly, the new lineage stays in the same village
					if (FF == T) {
						newLineage = Dictionary(village, c(counter));
					}
					
					// if fission isn't friendly, the new lineage goes to another village
					else {
						newVillage = sample(setDifference(villages.allKeys, village), 1); // sample a village
						newLineage = Dictionary(newVillage, c(counter));
						
						if (RF == F) {
							// update ID
							ID_newVillage = ID.getValue(newVillage);
							for (ind in asInteger(newLin)) {
								ID_newVillage = rbind(ID_newVillage, ID_village[which(ID_village[,0] == ind),]);
								ID_village = ID_village[which(ID_village[,0] != ind),];
							}
							ID.setValue(village, ID_village);
							ID.setValue(newVillage, ID_newVillage);
							sim.setValue("ID", ID);
						}
					}
					
					villages.appendKeysAndValuesFrom(newLineage); // add new lineage to its parent or new village
					
					// record fission
					fission = sim.getValue("fission");
					source = subpop.id;
					new = counter;
					fission = rbind(c(source, new), fission);
					
					sim.setValue("counter", counter);
					sim.setValue("fission", fission);
				}
				
				
				/// extinction (descent group without males) ///
				if (nMales == 0) {
					print('Extinction!');
					
					nExtinctions = nExtinctions + 1;
					
					// include remaining females in another group if necessary
					remainingInds = subpop.individuals;
					if (size(remainingInds) > 0) {
						possibleGroups = setDifference(pops, subpop);
						newGroup = sample(possibleGroups, 1);
						newGroup.takeMigrants(remainingInds);
					}
					
					// update villages
					groupID = villages.getValue(village);
					groups = setDifference(groupID, subpop.id);
					villages.setValue(village, groups);
					
					// update depth and growthRate
					depth.setValue(asString(subpop.id), NULL);
					growthRate[subpop.id - 1] = -1;
				}
				
				// extinction due to violence between lineages
				if (V == T) {
					// kill only males
					// condition : there are males in the lineage and in other lineages of the village
					if (nMales > 0 & nIndsM - nMales > 0) {
						// number of deaths in the lineage so that the number of deaths is inversely
						// proportionnal to the size of the lineage
						deathRate = (nIndsM - nMales) * rho * sqrt(nMales);
						nDeaths = rpois(n=1,lambda=deathRate);
						if (nDeaths > nMales) {
							nDeaths = nMales;
						}
						deadInds = subpop.sampleIndividuals(nDeaths, sex = 'M');
						sim.killIndividuals(deadInds);
						
						// extinction if there is no more individuals in the lineage
						if (nDeaths == nMales) {
							print("Extinction !");
							nExtinctions = nExtinctions + 1;
							
							// remove remaining females from subpop
							remainingInds = subpop.individuals;
							if (size(remainingInds) > 0) {
								sim.killIndividuals(remainingInds);
							}
							
							// update villages
							linID = villages.getValue(village);
							lineages = setDifference(linID, subpop.id);
							villages.setValue(village, lineages);
							
							// update depth and growth rate
							depth.setValue(asString(subpop.id), NULL);
							growthRate[subpop.id - 1] = -1;
						}
					}
				}
			}
		}
		// update lineages
		activeLin = sim.subpopulations[sim.subpopulations.individualCount > 0];
		realLin = c();
		for (village in villages.allKeys) {
			realLin = c(realLin, community.subpopulationsWithIDs(asInteger(villages.getValue(village))));
		}
		extinctLin = setDifference(activeLin, realLin);
		for (lin in extinctLin) {
			sim.killIndividuals(lin.individuals);
		}
		
		sim.setValue("villages", villages);
		sim.setValue("depth", depth);
		sim.setValue("growthRate", growthRate);
		sim.setValue('migrantRatioList', migrantRatioList);
		sim.setValue('nFissions', nFissions);
		sim.setValue("nExtinctions", nExtinctions);
		if (RF == F) {
			sim.setValue("linDepth", linDepth);
		}
		print("Elapsed (Fissions/Extinctions) : " + (clock() - start));
	}
}

20020 late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (lineage in villages.getValue(village)) {
			lin = sim.subpopulations[sim.subpopulations.id == lineage];
			indLin = lin.individuals[lin.individuals.age == 0];
			ind = c(ind, indLin);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_20.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20040 late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (lineage in villages.getValue(village)) {
			lin = sim.subpopulations[sim.subpopulations.id == lineage];
			indLin = lin.individuals[lin.individuals.age == 0];
			ind = c(ind, indLin);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_40.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20060	late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (lineage in villages.getValue(village)) {
			lin = sim.subpopulations[sim.subpopulations.id == lineage];
			indLin = lin.individuals[lin.individuals.age == 0];
			ind = c(ind, indLin);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_60.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20080 late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (lineage in villages.getValue(village)) {
			lin = sim.subpopulations[sim.subpopulations.id == lineage];
			indLin = lin.individuals[lin.individuals.age == 0];
			ind = c(ind, indLin);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_80.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20100 late() {
	villages = sim.getValue("villages");
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (lineage in villages.getValue(village)) {
			lin = sim.subpopulations[sim.subpopulations.id == lineage];
			indLin = lin.individuals[lin.individuals.age == 0];
			ind = c(ind, indLin);		}
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_100.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20100 late() {
	villages = sim.getValue("villages");
	lineages = community.subpopulationsWithIDs(asInteger(villages.getValue('V1')));
	p1.takeMigrants(lineages.individuals);
	
	lineages = community.subpopulationsWithIDs(asInteger(villages.getValue('V2')));
	p2.takeMigrants(lineages.individuals);
	
	lineages = community.subpopulationsWithIDs(asInteger(villages.getValue('V3')));
	p3.takeMigrants(lineages.individuals);
	
	lineages = community.subpopulationsWithIDs(asInteger(villages.getValue('V4')));
	p4.takeMigrants(lineages.individuals);
	
	lineages = community.subpopulationsWithIDs(asInteger(villages.getValue('V5')));
	p5.takeMigrants(lineages.individuals);
	
	if (RF == F) {
		sim.setValue("ID", NULL);
	}
	
	sim.setValue("K_village", asInteger(sum(sim.subpopulations.individualCount)/5));
}

20120 late() {
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_120.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20140 late() {
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_140.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20160 late() {
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_160.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20180 late() {
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_180.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20200 late() {
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_200.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}

20220 late() {
	filename = paste0(c('bash_Num_replicat/Sim_bash_Num_replicat_gen_220.trees'));
	print(filename);
	sim.treeSeqOutput(path = filename);
}